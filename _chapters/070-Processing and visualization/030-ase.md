---
title: ASE
slug: ase
abstract: ASE - это модуль языка Python, который призван облегчить анализ результатов МД-расчётов.
---

ASE - это модуль для языка Python, который призван облегчить анализ результатов МД-расчётов,
а в более сложных случаях и их запуск в необычных постановках, которые затруднительно сделать средствами самого расчётного кода.
Этот туториал посвящён базовым возможностям пакета ASE.
Курс предполагает знание Питона на базовом уровне и наличие хотя бы минимального опыта
атомистического моделирования любым из популярных пакетов, как классических (LAMMPS, GROMACS),
так и квантовых (VASP, Quantum Espresso и тд.).

Мы обсудим:
- Установку ASE;
- Конверсию между типами файлов;
- Создание атомистических структур;
- Калькуляторы: LAMMPS, VASP, сокеты i-PI (на примере FHI-Aims);
- Полезные вспомогательные модули (на примере Thermochemistry).

Материалы для запуска предлагаемых упражнений доступны по ссылке <ссылка>.

## Установка ASE

Как всегда с питоновскими пакетами, есть разные способы установки, предпочтительные для разных целей.
Самый простой способ - локальная установка для пользователя:
```
pip install --user ase
```
Этот способ вполне достаточен для простого юзера.
По желанию, можно установить для всех пользователей сразу (потребуются права администратора):
```
sudo pip install ase
```
Поскольку ASE написан на питоне, его можно модифицировать самостоятельно. 
Для этих целей НЕ рекомендуется использовать pip, вместо этого нужно клонировать проект на гитлабе:
```
git clone git@gitlab.com:ase/ase.git <your_local_folder>
```
Тогда можно создать свою ветку и хранить в ней свои модификации, или вообще сделать форк на гитлабе, чтобы делиться своими модификациями с сообществом.

---
## Чтение и запись различных форматов: класс ase.io

Простейшая задача, которая ускоряется с помощью ASE ‒ конверсия между различными популярными форматами атомистических структур. 
Модуль ase.io (https://wiki.fysik.dtu.dk/ase/ase/io/io.html) содержит методы для чтения и записи 
примерно 100 различных форматов файлов ввода/вывода различных пакетов.
Попробуем считать файл в формате пакета VASP (файл POSCAR) и преобразовать его в простейший формат XYZ
```python
import os
import numpy as np
import ase
from ase.io import read, write

atoms = read('POSCAR')
atoms
```

В переменную atoms был записан объект класса Atoms ‒ основной класс для хранения информации об атомистической системе.
Мы видим такие атрибуты как `symbols`, `pbc`, `cell`.
В `symbols` записана брутто-формула нашей системы, в `pbc` ‒ сведения о граничных условиях 
(`True` для периодических, `False` для непериодических). 
`cell` содержит Numpy-матрицу размером 3x3 с векторами расчётной ячейки в виде строк, или три параметра a1, a2, a3, если ячейка ортогональная.

Обратите внимание, что во многих случаях ASE успешно распознаёт формат данных и не требует явно его указывать. 
Для этого ASE анализирует имя файла и его расширение и сопоставляет их со своей базой. 
Однако это не будет работать, если имя и расширение нестандартные:
```python
bad_atoms = read("poscar.dat")
bad_atoms
```
Для нестандартных файлов необходимо указывать формат в явном виде:
```python
good_atoms = read("poscar.dat", format='vasp')
good_atoms
```

Запись в файл осуществляется так же просто и с теми же правилами указания форматов.
```python
write('1.xyz', good_atoms)
```
Посмотрим, что получилось:
```python
with open("1.xyz") as fdin:
    for line in fdin:
        print(line, end="")
```
Обратите внимание, что в общепринятом стандарте формата XYZ не предусмотрена запись векторов расчётной ячейки. 
2-я строка файла XYZ содержит произвольный комментарий.
ASE поступает иначе: использует эту строку для расширения формата и записи данных о ячейке и метаданных, 
позволяющих использовать тот же формат для записи скоростей, сил и прочих величин, 
определённых для каждого атома - т.н. Extended XYZ (extxyz). 
При чтении XYZ, ASE пытается распознать строку в формате extxyz, а при неудаче игнорирует её и не пишет 
параметры расчётной ячейки. Некоторые другие расчётные пакеты (i-PI) делают то же самое, 
но используют иную форму записи, поэтому в общем случае **XYZ-файлы могут быть несовместимы между собой**.

Если данные о ячейке не заданы в исходном файле, их можно добавить вручную:
```python
with open('2.xyz') as fdin:
    for line in fdin:
        print(line, end="")
        
atoms2 = read('2.xyz')
atoms2
atoms2.cell = np.asarray([[5, -5, 0], [5, 5, 0], [0, 0, 5]])
atoms2
```

---
## Классы Atoms и Atom

Объект класса Atoms сожержит в себе практически всю информацию о системе, подробное описание его весьма обширно: 
https://wiki.fysik.dtu.dk/ase/ase/atoms.html

Некоторые атрибуты объекта могут быть изменены напрямую - к ним относятся:

- numbers()
- symbols()
- positions()
- cell()
- pbc()
- constraints()
Однако для минимизации количества ошибок рекомендуется использовать специальные методы класса, 
такие как `set_positions` и т.п. Эти методы позволяют учитывать ограничения, наложенные на систему ранее. Мы рассмотрим это позже на примере constraints.

В качестве вспомогательного введён класс Atom, который представляет отдельный атом 
https://wiki.fysik.dtu.dk/ase/ase/atom.html 
Существуют различные способы инициализации атома:
```python
a1 = ase.Atom('Si', (0, 0, 0))
a2 = ase.Atom('H', (1.3, 0, 0), mass=2)
a3 = ase.Atom(14, position=(0, 0, 0))  # идентичен a1
a1, a2, a3
```

Класс Atoms позволяют осуществлять списочные операции над своими атомами: 
фильтрация по индексу, конкатенация, продолжение и тд:
```python
subset = atoms[0:2]
subset
```
С помощью list comprehension можно выбрать только атомы с определёными символами. 
Но следует быть осторожным, потому что list comprehension вернёт не объект класса Atoms, 
а список объектов Atom. 
Хотя из них можно собрать обратно объект Atoms, все глобальные свойства исходного объекта будут утрачены: 
параметры ячейки, назначенный калькулятор (о калькуляторах см. ниже) и тд.
```python
subset2 = ase.Atoms([atom for atom in atoms if atom.symbol=='H'])
subset2
```

При конкатенации ("сложении") двух объектов, глобальные свойства итогового объекта будут взяты из **первого** слагаемого:
```python
set1 = subset + subset2
set2 = subset2 + subset
set1, set2
```

---
## Генерация структур

ASE предлагает набор вспомогательных методов для генерации типовых структур, 
таких как молекулы, кристаллы и их поверхности. 
Простейший случай - библиотека геометрий простых молекул, доступная в функции `molecule`.
```python
from ase.build import molecule, bulk, fcc111, add_adsorbate, add_vacuum
from ase.visualize import view

water = molecule("H2O")
view(water)
water
```
Также можно создавать периодические кристаллы:
```python
cryst = bulk("Au", "fcc", 4.07)
view(cryst)
cryst2 = bulk("Au", "fcc", 4.07, orthorhombic=True)
view(cryst2)
```
и поверхности (т.н. "слэбы"):
```python
slab = fcc111("Au", (4, 4, 7), 4.07, periodic=True)
view(slab)
```
К поверхности можно легко добавить слой вакуума и адсорбат, попутно развернув молекулу воды:
```python
slab = fcc111("Au", (4, 4, 7), 4.07, vacuum=20, orthogonal=True, periodic=True)
add_adsorbate(slab, water, height=2.5, position=(3.0, 1.0))
water.euler_rotate(90, 90, 0)
add_adsorbate(slab, water, height=2.5, position=(3.0, 1.0), offset=(1, 1))
view(slab)
```

---
## Калькуляторы: расчёт энергии и сил, действующих на атомы

К объекту Atoms может быть прикреплён "калькулятор" - посторонний код для расчёта энергии и сил в системе. 
Это может быть классический МД код или ДФТ код. 
Рассмотрим на примере LAMMPS (https://wiki.fysik.dtu.dk/ase/ase/calculators/lammps.html#module-ase.calculators.lammps):
```python
from ase.calculators.lammpslib import LAMMPSLIB
```
---

---
    
